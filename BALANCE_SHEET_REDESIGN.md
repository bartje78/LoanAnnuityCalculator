# Balance Sheet Database Redesign

## Overview

This document describes the database redesign to create a single source of truth for balance sheet data, eliminating the need for complex frontend calculations and data aggregation from multiple sources.

## Problem Statement

The previous implementation had several issues:

1. **Scattered Data**: Balance sheet data was split across multiple tables:
   - `DebtorBalanceSheets`: Summary totals
   - `Loans`: Loan amounts and details
   - `Collaterals`: Property values
   
2. **Complex Frontend Logic**: The frontend had to:
   - Load balance sheet summaries
   - Load all loans and sum their outstanding amounts
   - Load all collateral and sum market values
   - Perform accounting calculations to build the complete picture

3. **No Single Source of Truth**: Different parts of the application could calculate values differently

4. **Difficult to Maintain**: Changes to balance sheet structure required updates in multiple places

## New Design

### Database Structure

#### 1. `DebtorBalanceSheets` (existing table - modified)
- **Purpose**: Stores summary totals and metadata for a balance sheet
- **Key Fields**:
  - `Id`: Primary key
  - `DebtorID`: Foreign key to debtor
  - `BookYear`: Year of the balance sheet
  - `CurrentAssets`: **Calculated sum** of line items
  - `LongTermAssets`: **Calculated sum** of line items
  - `CurrentLiabilities`: **Calculated sum** of line items
  - `LongTermLiabilities`: **Calculated sum** of line items
  - `OwnersEquity`: **Calculated** as Assets - Liabilities

#### 2. `BalanceSheetLineItems` (NEW table)
- **Purpose**: Stores detailed line items for each balance sheet entry
- **Key Fields**:
  - `Id`: Primary key
  - `BalanceSheetId`: Foreign key to `DebtorBalanceSheets`
  - `Category`: Category (CurrentAssets, FixedAssets, CurrentLiabilities, LongTermLiabilities, Equity)
  - `Label`: Display name (e.g., "Cash", "Residential Real Estate Amsterdam", "Bank Loan #1")
  - `Amount`: Monetary value
  - `LoanId`: (Optional) Reference to `Loans` table
  - `CollateralId`: (Optional) Reference to `Collaterals` table
  - `DisplayOrder`: Sort order within category
  - `Notes`: Additional information
  - `IsAutoGenerated`: Whether created automatically from loans/collateral

### Category Constants

```csharp
public static class BalanceSheetCategory
{
    public const string CurrentAssets = "CurrentAssets";
    public const string FixedAssets = "FixedAssets";
    public const string CurrentLiabilities = "CurrentLiabilities";
    public const string LongTermLiabilities = "LongTermLiabilities";
    public const string Equity = "Equity";
}
```

## Implementation Plan

### Phase 1: Data Migration Service

Create a service to populate line items from existing data:

```csharp
public class BalanceSheetMigrationService
{
    public async Task MigrateBalanceSheet(int balanceSheetId)
    {
        var balanceSheet = await _context.DebtorBalanceSheets
            .Include(bs => bs.DebtorDetails)
            .ThenInclude(d => d.Loans)
            .ThenInclude(l => l.LoanCollaterals)
            .ThenInclude(lc => lc.Collateral)
            .FirstOrDefaultAsync(bs => bs.Id == balanceSheetId);
        
        if (balanceSheet == null) return;
        
        var lineItems = new List<BalanceSheetLineItem>();
        int displayOrder = 1;
        
        // 1. Add current assets (manual entries - from uploaded balance sheet)
        if (balanceSheet.CurrentAssets > 0)
        {
            lineItems.Add(new BalanceSheetLineItem
            {
                BalanceSheetId = balanceSheet.Id,
                Category = BalanceSheetCategory.CurrentAssets,
                Label = "Current Assets (from uploaded balance sheet)",
                Amount = balanceSheet.CurrentAssets,
                DisplayOrder = displayOrder++,
                IsAutoGenerated = false
            });
        }
        
        // 2. Add fixed assets from collateral
        foreach (var loan in balanceSheet.DebtorDetails.Loans)
        {
            foreach (var loanCollateral in loan.LoanCollaterals)
            {
                var collateral = loanCollateral.Collateral;
                lineItems.Add(new BalanceSheetLineItem
                {
                    BalanceSheetId = balanceSheet.Id,
                    Category = BalanceSheetCategory.FixedAssets,
                    Label = $"{collateral.PropertyType} - {collateral.PropertyAddress}",
                    Amount = collateral.AppraisalValue ?? 0,
                    CollateralId = collateral.CollateralId,
                    DisplayOrder = displayOrder++,
                    IsAutoGenerated = true,
                    Notes = $"Appraisal date: {collateral.AppraisalDate?.ToString("yyyy-MM-dd")}"
                });
            }
        }
        
        // 3. Add current liabilities (manual entries)
        if (balanceSheet.CurrentLiabilities > 0)
        {
            lineItems.Add(new BalanceSheetLineItem
            {
                BalanceSheetId = balanceSheet.Id,
                Category = BalanceSheetCategory.CurrentLiabilities,
                Label = "Current Liabilities (from uploaded balance sheet)",
                Amount = balanceSheet.CurrentLiabilities,
                DisplayOrder = displayOrder++,
                IsAutoGenerated = false
            });
        }
        
        // 4. Add long-term liabilities from loans
        foreach (var loan in balanceSheet.DebtorDetails.Loans)
        {
            lineItems.Add(new BalanceSheetLineItem
            {
                BalanceSheetId = balanceSheet.Id,
                Category = BalanceSheetCategory.LongTermLiabilities,
                Label = $"Loan #{loan.LoanID} - {loan.AnnualInterestRate}% over {loan.TenorMonths} months",
                Amount = loan.OutstandingAmount, // This is a calculated property
                LoanId = loan.LoanID,
                DisplayOrder = displayOrder++,
                IsAutoGenerated = true,
                Notes = $"Started: {loan.StartDate:yyyy-MM-dd}, Status: {loan.Status}"
            });
        }
        
        // 5. Add manual long-term liabilities (from uploaded balance sheet - if not covered by loans)
        decimal totalAutoGeneratedLTL = lineItems
            .Where(li => li.Category == BalanceSheetCategory.LongTermLiabilities && li.IsAutoGenerated)
            .Sum(li => li.Amount);
            
        decimal manualLTL = balanceSheet.LongTermLiabilities - totalAutoGeneratedLTL;
        if (manualLTL > 0)
        {
            lineItems.Add(new BalanceSheetLineItem
            {
                BalanceSheetId = balanceSheet.Id,
                Category = BalanceSheetCategory.LongTermLiabilities,
                Label = "Other Long-Term Liabilities (from uploaded balance sheet)",
                Amount = manualLTL,
                DisplayOrder = displayOrder++,
                IsAutoGenerated = false
            });
        }
        
        // Save line items
        _context.BalanceSheetLineItems.AddRange(lineItems);
        await _context.SaveChangesAsync();
        
        // Recalculate summary totals
        await RecalculateTotals(balanceSheet.Id);
    }
    
    public async Task RecalculateTotals(int balanceSheetId)
    {
        var balanceSheet = await _context.DebtorBalanceSheets
            .Include(bs => bs.LineItems)
            .FirstOrDefaultAsync(bs => bs.Id == balanceSheetId);
            
        if (balanceSheet == null) return;
        
        balanceSheet.CurrentAssets = balanceSheet.LineItems
            .Where(li => li.Category == BalanceSheetCategory.CurrentAssets)
            .Sum(li => li.Amount);
            
        balanceSheet.LongTermAssets = balanceSheet.LineItems
            .Where(li => li.Category == BalanceSheetCategory.FixedAssets)
            .Sum(li => li.Amount);
            
        balanceSheet.CurrentLiabilities = balanceSheet.LineItems
            .Where(li => li.Category == BalanceSheetCategory.CurrentLiabilities)
            .Sum(li => li.Amount);
            
        balanceSheet.LongTermLiabilities = balanceSheet.LineItems
            .Where(li => li.Category == BalanceSheetCategory.LongTermLiabilities)
            .Sum(li => li.Amount);
            
        decimal totalAssets = balanceSheet.CurrentAssets + balanceSheet.LongTermAssets;
        decimal totalLiabilities = balanceSheet.CurrentLiabilities + balanceSheet.LongTermLiabilities;
        balanceSheet.OwnersEquity = totalAssets - totalLiabilities;
        
        await _context.SaveChangesAsync();
    }
}
```

### Phase 2: API Endpoints

Update the DebtorController to expose line items:

```csharp
[HttpGet("{id}/balance-sheet-details")]
public async Task<ActionResult<BalanceSheetWithLineItemsDto>> GetBalanceSheetDetails(int id)
{
    var balanceSheet = await _context.DebtorBalanceSheets
        .Include(bs => bs.LineItems)
        .ThenInclude(li => li.Loan)
        .Include(bs => bs.LineItems)
        .ThenInclude(li => li.Collateral)
        .Where(bs => bs.DebtorID == id)
        .OrderByDescending(bs => bs.BookYear)
        .FirstOrDefaultAsync();
        
    if (balanceSheet == null)
        return NotFound();
        
    return Ok(new BalanceSheetWithLineItemsDto
    {
        Id = balanceSheet.Id,
        BookYear = balanceSheet.BookYear,
        CurrentAssets = balanceSheet.CurrentAssets,
        LongTermAssets = balanceSheet.LongTermAssets,
        CurrentLiabilities = balanceSheet.CurrentLiabilities,
        LongTermLiabilities = balanceSheet.LongTermLiabilities,
        OwnersEquity = balanceSheet.OwnersEquity,
        LineItems = balanceSheet.LineItems
            .OrderBy(li => li.Category)
            .ThenBy(li => li.DisplayOrder)
            .Select(li => new BalanceSheetLineItemDto
            {
                Id = li.Id,
                Category = li.Category,
                Label = li.Label,
                Amount = li.Amount,
                Notes = li.Notes,
                IsAutoGenerated = li.IsAutoGenerated,
                LoanReference = li.Loan != null ? new LoanReferenceDto
                {
                    LoanId = li.Loan.LoanID,
                    Rate = li.Loan.AnnualInterestRate,
                    OutstandingAmount = li.Loan.OutstandingAmount
                } : null,
                CollateralReference = li.Collateral != null ? new CollateralReferenceDto
                {
                    CollateralId = li.Collateral.CollateralId,
                    PropertyType = li.Collateral.PropertyType,
                    Address = li.Collateral.PropertyAddress,
                    AppraisalValue = li.Collateral.AppraisalValue,
                    AppraisalDate = li.Collateral.AppraisalDate
                } : null
            })
            .ToList()
    });
}
```

### Phase 3: Frontend Updates

Simplify the frontend to just load and display line items:

```typescript
async loadBalanceSheet(debtorId: number): Promise<void> {
    const response = await this.http.get<BalanceSheetWithLineItems>(
        `${this.apiUrl}/api/debtor/${debtorId}/balance-sheet-details`
    ).toPromise();
    
    this.balanceSheet = response;
    
    // Group line items by category for display
    this.currentAssets = response.lineItems.filter(li => li.category === 'CurrentAssets');
    this.fixedAssets = response.lineItems.filter(li => li.category === 'FixedAssets');
    this.currentLiabilities = response.lineItems.filter(li => li.category === 'CurrentLiabilities');
    this.longTermLiabilities = response.lineItems.filter(li => li.category === 'LongTermLiabilities');
    
    // Summary totals come from the API
    this.totalAssets = response.currentAssets + response.longTermAssets;
    this.totalLiabilities = response.currentLiabilities + response.longTermLiabilities;
    this.equity = response.ownersEquity;
}
```

### Phase 4: Monte Carlo Updates

Simplify Monte Carlo initialization:

```typescript
// OLD CODE - REMOVE
const collateralValue = latestBalanceSheet.TotalCollateralValue || 0;
const loanDebt = this.debtorLoans.reduce((sum, loan) => sum + loan.OutstandingAmount, 0);
this.initialAssets = baseAssets + collateralValue;
this.initialDebt = baseLiabilities + loanDebt;

// NEW CODE - SIMPLIFIED
this.initialAssets = latestBalanceSheet.CurrentAssets + latestBalanceSheet.LongTermAssets;
this.initialDebt = latestBalanceSheet.CurrentLiabilities + latestBalanceSheet.LongTermLiabilities;
```

## Benefits

1. **Single Source of Truth**: All balance sheet data comes from one place
2. **Simplified Frontend**: No complex calculations or data aggregation needed
3. **Better Auditability**: Each line item is tracked individually
4. **Flexible Structure**: Easy to add custom line items (e.g., "Other assets", "Provisions")
5. **Referential Integrity**: Links to actual loans and collateral maintained
6. **Easier Maintenance**: Changes to balance sheet structure only need backend updates

## Migration Strategy

1. âœ… Create `BalanceSheetLineItems` table (migration applied)
2. Create migration service to populate line items from existing data
3. Run migration for all existing balance sheets
4. Update API endpoints to return line items
5. Update frontend to use new structure
6. Remove old calculation logic from frontend
7. Test thoroughly with existing data
8. Consider deprecating `FirstLienLoan` fields on balance sheet once migrated

## Next Steps

1. Implement the `BalanceSheetMigrationService`
2. Create an admin endpoint to trigger migration for specific debtors
3. Create DTOs for the new API response structure
4. Update frontend components to use new API
5. Test with existing debtor data
